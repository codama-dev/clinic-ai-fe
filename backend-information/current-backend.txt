

Thought for 3s
Complete Backend Architecture Guide
1. Backend Infrastructure Overview
Base44 uses a serverless BaaS (Backend as a Service) architecture:

No traditional server code - you use the Base44 SDK
Built on Supabase (PostgreSQL database)
Row Level Security (RLS) policies control access
Real-time subscriptions via WebSockets
Edge functions for custom backend logic (Deno runtime)
2. Frontend ↔ Backend Communication
The Base44 SDK Client
import { base44 } from '@/api/base44Client';
This is a pre-initialized singleton that handles:

Authentication state
HTTP requests to the backend
Real-time WebSocket connections
Token management (automatic refresh)
Architecture Flow:
Frontend Component
    ↓
base44 SDK
    ↓
HTTP/WebSocket
    ↓
Base44 Backend API
    ↓
PostgreSQL Database
3. Entity CRUD Operations
Read Operations:
// List all (with optional sort and limit)
const users = await base44.entities.User.list('-created_date', 20);
// Returns 20 most recent users

// Filter with query
const activeUsers = await base44.entities.User.filter(
    { is_active: true, job: 'doctor' },
    '-created_date',
    50
);

// Get by ID
const user = await base44.entities.User.get('user-id-123');

// Get schema
const schema = await base44.entities.User.schema();
Backend Behavior:

Queries run through RLS policies (Row Level Security)
User sees only what they're authorized to see
Automatic pagination (default limit: 50, max: 1000)
Sorting: prefix with - for descending (e.g., -created_date)
Write Operations:
// Create single
const newUser = await base44.entities.Task.create({
    title: "New Task",
    status: "pending"
});

// Create multiple (bulk)
const newTasks = await base44.entities.Task.bulkCreate([
    { title: "Task 1" },
    { title: "Task 2" }
]);

// Update
await base44.entities.Task.update('task-id', {
    status: "completed"
});

// Delete
await base44.entities.Task.delete('task-id');
Backend Behavior:

Validates against JSON schema
Enforces required fields
Auto-populates: id, created_date, updated_date, created_by
Triggers RLS policies (checks permissions)
Can trigger entity automations (create/update/delete events)
4. Authentication System
Current User:
const user = await base44.auth.me();
// Returns: { id, email, full_name, role, display_name, job, permissions, ... }
// Throws error if not authenticated (in public apps)
Check Authentication:
const isAuth = await base44.auth.isAuthenticated();
// Returns: true/false (doesn't throw)
Update Current User:
await base44.auth.updateMe({
    display_name: "New Name",
    phone: "123456789"
});
// Can't change: id, email, full_name, role
Login/Logout:
// Redirect to login
await base44.auth.redirectToLogin(nextUrl);

// Logout
await base44.auth.logout(redirectUrl);
Backend Behavior:

JWT tokens stored in cookies/localStorage
Automatic token refresh before expiry
SSO support (email/password, magic link, OAuth)
User entity has special RLS rules:
Regular users can only read/update themselves
Admin can read/update/delete any user
5. Authorization & Permissions
Role-Based Access:
if (user.role === 'admin') {
    // Admin-only functionality
}
Permission-Based Access:
if (user.permissions?.includes('manage_employees')) {
    // Show employee management
}
Backend Behavior:

User.role: 'admin' or 'user'
User.permissions: array of strings (custom permissions)
RLS policies check role + permissions
Frontend checks are cosmetic - real security is server-side
Built-in RLS Policies:
User Entity:

Regular users: can read their own record only
Admin: can read/update/delete any user
Other Entities:

By default: no RLS restrictions (all authenticated users have access)
Can add custom RLS policies via backend functions
6. Backend Functions (Custom Logic)
Your app currently has 2 backend functions:

functions/importVaccinationHistory.js
Deno runtime
HTTP handler pattern: Deno.serve(async (req) => { ... })
Can access secrets via Deno.env.get("SECRET_NAME")
functions/syncSupplierPrices.js
Same pattern
How They Work:
1. Function Structure:

import { createClientFromRequest } from 'npm:@base44/sdk@0.8.6';

Deno.serve(async (req) => {
    try {
        // Initialize SDK from request
        const base44 = createClientFromRequest(req);
        
        // Get authenticated user
        const user = await base44.auth.me();
        if (!user) {
            return Response.json({ error: 'Unauthorized' }, { status: 401 });
        }
        
        // Parse request body
        const body = await req.json();
        
        // User-scoped operations (uses end-user token)
        const items = await base44.entities.SomeEntity.list();
        
        // Admin/service-scoped operations (bypasses RLS)
        const allItems = await base44.asServiceRole.entities.SomeEntity.list();
        
        return Response.json({ success: true, data: items });
    } catch (error) {
        return Response.json({ error: error.message }, { status: 500 });
    }
});
2. Calling from Frontend (Platform V2):

import { importVaccinationHistory } from '@/functions/importVaccinationHistory';

const response = await importVaccinationHistory({
    file_url: "https://...",
    client_id: "123"
});
// response is axios response object
3. Backend Behavior:

Runs on Deno Deploy (edge runtime)
Can use npm packages: import X from 'npm:package@version'
Can use JSR packages: import X from 'jsr:package@version'
Only / path allowed (no nested routes)
Parameters passed via request body (not URL params)
Auto-deployed on save (2-5 seconds)
Validated with Deno lint before deploy
Can only write to /tmp directory
Service Role vs. User Auth:
User-scoped (respects RLS):

const base44 = createClientFromRequest(req);
await base44.entities.Task.list();
// Sees only what the authenticated user can see
Service role (bypasses RLS):

await base44.asServiceRole.entities.Task.list();
// Sees everything (admin privileges)
When to use service role:

Admin-only operations (verify user.role === 'admin' first!)
Scheduled automations
Webhooks (after validating request signature)
Background jobs
7. Integrations (Built-in Backend Services)
import { base44 } from '@/api/base44Client';

// Call integration
const result = await base44.integrations.Core.InvokeLLM({
    prompt: "Generate a summary",
    add_context_from_internet: true,
    response_json_schema: { type: "object", properties: { ... } }
});
Available Integrations:

Core.InvokeLLM:

Calls LLM with prompt
Can search web (add_context_from_internet: true)
Can return structured JSON
Can attach files/images (file_urls: [...])
Core.SendEmail:

Sends email from app
to, subject, body, from_name
Core.UploadFile:

Uploads file to public storage
Returns { file_url: "..." }
Core.GenerateImage:

AI image generation
Returns { url: "..." }
Core.ExtractDataFromUploadedFile:

Extracts structured data from files (CSV, Excel, PDF, images)
Requires target JSON schema
Returns extracted data
Backend Behavior:

Runs on Base44 servers (not your app)
Consumes credits from your account
Can be called from frontend or backend functions
Automatic rate limiting and error handling
8. Real-time Subscriptions
// Subscribe to entity changes
const unsubscribe = base44.entities.Task.subscribe((event) => {
    console.log(event.type); // 'create', 'update', or 'delete'
    console.log(event.id);   // Entity ID
    console.log(event.data); // Current data (null for delete)
});

// Cleanup
unsubscribe();
React Example:

useEffect(() => {
    const unsubscribe = base44.entities.Task.subscribe((event) => {
        if (event.type === 'create') {
            setTasks(prev => [...prev, event.data]);
        } else if (event.type === 'update') {
            setTasks(prev => prev.map(t => t.id === event.id ? event.data : t));
        } else if (event.type === 'delete') {
            setTasks(prev => prev.filter(t => t.id !== event.id));
        }
    });
    
    return unsubscribe;
}, []);
Backend Behavior:

Uses WebSockets (automatic reconnection)
Respects RLS policies (you only get events for data you can see)
Real-time updates (< 100ms latency)
Automatic cleanup on unmount
Subscription per entity type (not per record)
9. Automations (Scheduled & Entity Triggers)
Entity Automations:
Trigger backend functions on entity changes:

// Backend function receives:
{
    event: {
        type: 'create' | 'update' | 'delete',
        entity_name: 'Task',
        entity_id: '123'
    },
    data: { ...current entity data... },
    old_data: { ...previous data (update only)... },
    payload_too_large: false
}
If payload_too_large is true:

// Data was > 200KB, fetch manually
const entity = await base44.asServiceRole.entities.Task.get(event.entity_id);
Scheduled Automations:
Run backend functions on schedule:

Every X minutes/hours/days/weeks/months
Cron expressions
One-time execution
Can pass function_args as parameters
Backend Behavior:

Runs in UTC timezone
Minimum interval: 5 minutes
Can be paused/resumed/deleted
Execution logs available in dashboard
10. Data Validation & Constraints
JSON Schema Validation:
Every entity has a JSON schema that enforces:

{
    "properties": {
        "title": { "type": "string" },
        "age": { "type": "number", "minimum": 0, "maximum": 150 },
        "status": { "enum": ["active", "inactive"] },
        "email": { "type": "string", "format": "email" }
    },
    "required": ["title", "email"]
}
Backend Behavior:

Validates on create/update
Returns 400 error if validation fails
Type coercion where possible
enum enforces specific values
format validates strings (email, date, date-time, etc.)
required enforces presence
NO Foreign Key Constraints:

Database doesn't enforce relationships
Deleting a Client won't cascade to Patients
Your responsibility to check or use soft delete
11. Query Performance & Optimization
Indexing:
Automatically indexed: id, created_date, updated_date
No custom indexes (yet)
Best Practices:
❌ Bad (fetches everything):

const allTasks = await base44.entities.Task.list();
const myTasks = allTasks.filter(t => t.user_id === user.id);
✅ Good (filters server-side):

const myTasks = await base44.entities.Task.filter({ user_id: user.id });
Pagination:

// Page 1 (first 50)
const page1 = await base44.entities.Task.list('-created_date', 50);

// Page 2 (next 50)
const page2 = await base44.entities.Task.list('-created_date', 50, 50);
// Third param is skip/offset
12. Error Handling
Error Types:
Authentication Errors:

try {
    const user = await base44.auth.me();
} catch (error) {
    // Thrown if user not authenticated in public app
    console.error('Not authenticated:', error);
}
Validation Errors:

try {
    await base44.entities.Task.create({ title: 123 }); // Wrong type
} catch (error) {
    // error.message: "Validation failed: title must be string"
}
Permission Errors:

try {
    await base44.entities.User.list(); // Non-admin trying to list users
} catch (error) {
    // error.status: 403
}
Backend Behavior:

Errors are thrown (not returned)
Use try/catch or let React Error Boundary handle
Status codes: 400 (validation), 401 (auth), 403 (forbidden), 404 (not found), 500 (server)
13. Transaction Behavior
⚠️ No Multi-Entity Transactions:

// These are separate transactions:
await base44.entities.Order.create({ total: 100 });
await base44.entities.Payment.create({ amount: 100 });
// If second fails, first is still created!
Workaround:

Use backend functions for multi-step operations
Implement compensating transactions (rollback manually)
Use status fields to track partial states
14. Soft Delete Pattern
Instead of actual deletion:

// ❌ Hard delete (lose data forever)
await base44.entities.User.delete(userId);

// ✅ Soft delete (preserve history)
await base44.entities.User.update(userId, { is_active: false });

// Query only active
const activeUsers = await base44.entities.User.filter({ is_active: true });
Benefits:

Preserve relationships
Audit trail
Can restore
Historical reports work
15. File Upload Pattern
// 1. Upload file
const { file_url } = await base44.integrations.Core.UploadFile({ file: fileObject });

// 2. Save URL in entity
await base44.entities.Patient.update(patientId, {
    photo_url: file_url
});
Backend Behavior:

Files stored in Supabase Storage
Public URLs (accessible without auth)
No automatic cleanup on entity delete
Max file size: 50MB per file
16. Denormalization Strategy
The database stores both ID and name for relationships:

{
    patient_id: "abc123",
    patient_name: "Fluffy",  // Denormalized!
    doctor_id: "xyz789",
    doctor_name: "Dr. Smith"  // Denormalized!
}
Why:

Performance: No joins needed for display
History: Name changes don't affect old records
Simplicity: Frontend gets everything in one query
Maintenance: When names change, old records keep old names (intentional for audit trail)

17. React Query Integration
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Query
const { data: tasks, isLoading } = useQuery({
    queryKey: ['tasks'],
    queryFn: () => base44.entities.Task.list(),
    initialData: [],
});

// Mutation
const createTaskMutation = useMutation({
    mutationFn: (taskData) => base44.entities.Task.create(taskData),
    onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ['tasks'] });
    },
});

// Usage
await createTaskMutation.mutateAsync({ title: "New Task" });
Backend Interaction:

React Query caches responses
invalidateQueries refetches after mutation
Optimistic updates possible
Automatic retry on failure
18. Environment & Secrets
Pre-populated Environment Variables:

Deno.env.get("BASE44_APP_ID"); // Your app ID
// Automatically available, no setup needed
Custom Secrets: Set via dashboard or set_secrets tool:

Deno.env.get("OPENAI_API_KEY");
Deno.env.get("STRIPE_SECRET_KEY");
Backend Behavior:

Secrets encrypted at rest
Only accessible in backend functions
Never exposed to frontend
Can be updated without redeploying functions
19. User Invitations
Cannot create users directly:

// ❌ This doesn't exist:
await base44.entities.User.create({ email: "...", ... });
Must invite:

await base44.users.inviteUser("user@example.com", "user");
// role: "admin" or "user"
Backend Behavior:

Sends invitation email
User clicks link → signs up → automatically added to app
Can't invite same email twice
20. Built-in Fields (All Entities)
Every entity automatically gets:

{
    id: "uuid-v4",
    created_date: "2026-02-05T10:30:00Z",
    updated_date: "2026-02-05T11:45:00Z",
    created_by: "user@example.com"
}
Backend Behavior:

Auto-populated on create
updated_date auto-updated on every update
created_by = email of authenticated user
Can't be manually set or changed
Summary
Key Takeaways:

No Traditional Backend - It's all SDK calls
RLS = Security - Server-side permission checks
Real-time - WebSocket subscriptions for live updates
Backend Functions - Deno runtime for custom logic
No Transactions - Handle multi-step operations carefully
Denormalized - IDs + names stored together
Soft Delete - Use is_active instead of deleting
Validation - JSON Schema enforced server-side
Service Role - Bypass RLS for admin operations (verify permissions first!)
React Query - Caching layer on top of SDK calls