Complete Backend Endpoints Reference
1. Entity CRUD (Generic for all 44 entities)
GET /api/entities/:entityName
Purpose: List entities with pagination and sorting
Payload: Query params { sort?, limit?, offset? }
Response: { data: Entity[], count: number }
Current: base44.entities.EntityName.list(sort, limit)
Implementation: Query Supabase table with RLS, apply sort/limit
POST /api/entities/:entityName/filter
Purpose: Filter entities by query conditions
Payload: { query: { field: value, ... }, sort?, limit?, offset? }
Response: { data: Entity[], count: number }
Current: base44.entities.EntityName.filter(query, sort, limit)
Implementation: Build WHERE clauses from query object, support operators like $gte, $lte
GET /api/entities/:entityName/:id
Purpose: Get single entity by ID
Payload: URL param id
Response: Entity
Current: base44.entities.EntityName.get(id)
Implementation: SELECT WHERE id = ? with RLS
POST /api/entities/:entityName
Purpose: Create new entity
Payload: { field: value, ... } (entity data)
Response: Entity (created record with auto-generated fields)
Current: base44.entities.EntityName.create(data)
Implementation: Validate against JSON schema, INSERT with auto id, created_date, created_by
POST /api/entities/:entityName/bulk
Purpose: Create multiple entities at once
Payload: { data: [{ field: value }, ...] }
Response: Entity[]
Current: base44.entities.EntityName.bulkCreate(dataArray)
Implementation: Validate all, single INSERT with multiple rows
PATCH /api/entities/:entityName/:id
Purpose: Update entity
Payload: { field: value, ... } (partial update allowed)
Response: Entity (updated record)
Current: base44.entities.EntityName.update(id, data)
Implementation: UPDATE WHERE id = ?, auto-update updated_date
DELETE /api/entities/:entityName/:id
Purpose: Delete entity
Payload: URL param id
Response: { success: true }
Current: base44.entities.EntityName.delete(id)
Implementation: DELETE WHERE id = ? (no cascade)
GET /api/entities/:entityName/schema
Purpose: Get JSON schema for validation
Payload: None
Response: { type: "object", properties: {...}, required: [...] }
Current: base44.entities.EntityName.schema()
Implementation: Return loaded JSON schema from file
2. Authentication Endpoints
GET /api/auth/me
Purpose: Get current authenticated user
Payload: Header Authorization: Bearer <token>
Response: User object with all fields
Current: base44.auth.me()
Implementation: Verify JWT, SELECT from users WHERE id = auth.uid()
GET /api/auth/is-authenticated
Purpose: Check if token is valid
Payload: Header Authorization: Bearer <token>
Response: { authenticated: boolean }
Current: base44.auth.isAuthenticated()
Implementation: Try to verify JWT, return true/false without throwing
PATCH /api/auth/me
Purpose: Update current user's profile
Payload: { display_name?, phone?, job?, ... } (can't change id, email, role)
Response: User (updated)
Current: base44.auth.updateMe(data)
Implementation: UPDATE users WHERE id = auth.uid(), block protected fields
POST /api/auth/login
Purpose: Login with email/password
Payload: { email: string, password: string }
Response: { access_token: string, refresh_token: string, user: User }
Current: Handled by Supabase redirect
Implementation: Call Supabase Auth signInWithPassword, return tokens
POST /api/auth/logout
Purpose: Logout user
Payload: Header Authorization: Bearer <token>
Response: { success: true }
Current: base44.auth.logout()
Implementation: Call Supabase Auth signOut, invalidate token
POST /api/auth/invite
Purpose: Invite new user (admin only)
Payload: { email: string, role: "user" | "admin" }
Response: { success: true, user: User }
Current: base44.users.inviteUser(email, role)
Implementation: Check admin, call Supabase inviteUserByEmail, INSERT into users table
3. Real-time Subscriptions (WebSocket)
WS /realtime?token=<jwt>
Purpose: Subscribe to entity changes
Client sends: { type: "subscribe", entityName: "Task" }
Server sends: { type: "create|update|delete", entity_name: "Task", id: "...", data: {...} }
Current: base44.entities.Task.subscribe(callback)
Implementation:
Client connects to WebSocket with JWT
Server verifies token, stores subscription
Listen to Supabase Realtime on all tables
Broadcast changes to subscribed clients only
4. File Upload
POST /api/integrations/core/upload-file
Purpose: Upload file to storage
Payload: multipart/form-data with file field
Response: { file_url: string }
Current: base44.integrations.Core.UploadFile({ file })
Implementation: Use Supabase Storage API to upload to public bucket, return URL
5. Integration Endpoints (Optional)
POST /api/integrations/core/invoke-llm
Purpose: Call LLM service
Payload: { prompt: string, add_context_from_internet?: boolean, response_json_schema?: object, file_urls?: string[] }
Response: string or object (if schema provided)
Current: base44.integrations.Core.InvokeLLM(...)
Implementation: Proxy to external LLM API (OpenAI, Anthropic, etc.)
POST /api/integrations/core/send-email
Purpose: Send email
Payload: { to: string, subject: string, body: string, from_name?: string }
Response: { success: true }
Current: base44.integrations.Core.SendEmail(...)
Implementation: Use SMTP service or email API (SendGrid, Resend, etc.)
6. Custom Functions (Dynamic)
POST /api/functions/:functionName
Purpose: Execute custom backend function
Payload: any (function-specific)
Response: any (function-specific)
Current: base44.functions.invoke(functionName, payload) or import { functionName } from '@/functions/functionName'
Implementation:
Load function code from functions/{functionName}.js
Execute in isolated context with user token
Return response
Your 2 existing functions:

importVaccinationHistory - Takes file URL, extracts vaccination data
syncSupplierPrices - Syncs supplier price data
Implementation Priority
Phase 1 (Core):

Entity CRUD (all 8 endpoints) ✓
Authentication (5 endpoints) ✓
Complete all 44 SQL schemas ❌
Phase 2 (Real-time): 4. WebSocket subscriptions ✓

Phase 3 (Storage): 5. File upload endpoint

Phase 4 (Optional): 6. Integration proxies (LLM, Email) 7. Custom function runner